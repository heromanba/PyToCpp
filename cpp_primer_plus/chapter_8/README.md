
# 第8章 函数探幽

本章内容包括：
- 内联函数。
- 引用变量。
- 如何按引用传递函数。
- 默认参数。
- 函数重载。
- 函数摸版。
- 函数摸版具体化。

## 8.2 引用变量

### 8.2.1 创建引用变量

### 8.2.2 将引用用作函数参数

### 8.2.3 引用的属性和特别之处

```cpp
double refcube(double &ra);
```
对于上述函数声明，ra是一个变量的别名，实参应该是该变量。下面的代码不合理，因为表达式```x + 3.0```并不是变量：
```cpp
double z = refcube(x + 3.0);    // should not compile
```

#### 临时变量、引用参数和const
如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才允许这样做，但以前不是这样。

如果引用参数是const，则编译器将在下面两种情况生成临时变量：
- 实参的类型正确，但不是左值；
- 实参的类型不正确，但可以转换为正确的类型。

### 8.2.4 将引用用于结构

### 8.2.5 将引用用于类对象

### 8.2.6 对象、继承和引用

### 8.2.7 何时使用引用参数

使用引用参数的主要原因有两个：
- 程序员能够修改调用函数中的数据对象。
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

对于使用传递的值而不作修改的函数：
- 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
- 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
- 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
- 如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：
- 如果数据对象是内置数据类型，则使用指针。如果看到注入```fixit(&x)```这样的代码（其中x是int），则很明显，该函数将修改x。
- 如果数据对象是数组，则只能使用指针。
- 如果数据对象是结构，则使用引用或指针。
- 如果数据对象是类对象，则使用引用。


## 8.3 默认参数

如何设置默认值呢？必须通过函数原型。


## 8.4 函数重载

C++使用上下文来确定要使用的重载函数版本。

函数重载的关键是函数的参数列表--也被称为函数特征标（function signature）。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则他们的特征标相同，而变量名是无关紧要的。

为避免混乱，编译器在检查函数特征标时，将把类型引用和类型本身视为同一特征标。

### 重载引用参数

参数可分为：左值、const、右值。

### 8.4.1 重载示例

### 8.4.2 何时使用函数重载

仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

如果需要使用不同类型的参数，则默认参数便不管用了，在这种情况下，应该使用函数重载。

#### 什么是名称修饰

对原始名称进行的表面看起来无意义的修饰将对参数数目和类型进行编码。添加的一组符号随函数特征标而异，而修饰时使用的约定随编译器而异。


## 函数模版

### 8.5.1 重载的模版

### 8.5.2 模版的局限性

### 8.5.3 显式具体化

### 8.5.4 实例化和具体化

### 8.5.5 编译器选择使用哪个函数版本

### 8.5.6 模版函数的发展